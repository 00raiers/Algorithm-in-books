// 编程之美 2.21
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// 任意给定一个64位正整数N，将N分成几个连续自然数的和
// 例如： 9 = 4 + 5 = 2 + 3 + 4
// 1. 写出所有可能的形式
// 2. 证明哪些数字不能写成上述形式
// 3. 求出子序列最多的数
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// 思路：
// 1. 如果某个数能写成k个自然数的和，假设最小的自然数为n，则
// N = n + (n+1) + ... + (n + k -1) = kn + k(k-1)/2
// 2. 因为n最小为1，此时k最大，k * (k + 1) = N，
// 所以，k < sqrt(2 * N)
// 3. 如果某个数可以写成这样的形式，那么它肯定能被3,5,7,9,
// 11,13...的某个奇数整除。所以，如果某个数不能写成这样的
// 形式，那么它肯定是2的n次幂
// 4. 如果k为奇数的话，必定有：N = k * (n + (k-1)/2)满足
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#include <iostream>
#include <math.h>

using namespace std;

/************************************************************************/
/*函数名：DecomN
/*功  能：计数正整数可以分解成多少组连续自然数的和
/*返回值：不同分解的个数
/************************************************************************/
int DecomN(long long int N)
{
    int iCount = 0;
    long long int liNum = 0;

    for (long long int k = 2; k < sqrt(2 * N); ++k)
    {
        liNum = N - k * (k - 1) / 2;

        if (liNum > 0 && liNum / k * k == liNum)
        {
            iCount++;
            // cout << "形式：" << k << " " << liNum / k << endl;
        }
    }

    return iCount;
}



int main()
{
    long long int N = 1254641;

    cout << DecomN(N) << endl;

    return 0;
}
